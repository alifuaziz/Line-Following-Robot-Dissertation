\section{Discussion and Further Work}

\paragraph{Summary of Results}

Using an object oriented approach, the program is able to perform the task required by the design brief (Section \ref{section:design_brief}). Allowing many more positions for the animal to choose from rather than the 37 of the original Honeycomb Maze. The path-finding method was implemented taking into account the inherent design constraints. This provides greater functionality for investigating cognitive maps for a relatively reduced cost to the lab.

% Solution solved, and here is why you should care

\paragraph{Impact of the program}

Since this program is written in Python, it allows integration with computer vision software such as \textit{deeplabcut} \cite{dlc}, allowing the animal-maze interaction to be automated.

A functioning version of this program has been uploaded to \href{https://github.com/casualcoffeeaddict/Honeycomb-Maze}{GitHub}. This means that for relatively little financial cost, it would be possible for the tool to be developed in many laboratories investigating animal models of spatial cognition. This means it could be used more widely than just well funded laboratories. This tool can be used more widely in laboratories investigating spatial memory.  

\paragraph{Integration Testing}

There are many parts to the logic of this program that interact in complex ways so example scripts were written of the program working in different initial positions. This tests integration of all the different components of the program, which are working together for many different configurations that the program can be presented with. This makes sure the program is written in a robust way.

\subsection{Limitations and further development}

\paragraph{How well the algorithm can generalise} In the overall algorithm, the pre- and post- path-finding methods were programmed such that they must always be performed under this version of the algorithm. The order of the of operations for this version of the program is also set hard-coded (i.e. NNAR moves first, NAR moves second). % Generalising this to a larger number of robots would require a function.

Due to these steps, the algorithm is not completely general; for more than three platforms, the algorithm will not work. Despite this, the algorithm is able to handle all the cases of movement that are required (except in cases where the animal robot is close to the corner of the area of the maze).
Because of the object oriented structure of the code \cite{SOLID_book}, it is easy to implement new the features, such as the following, required upon further development. 

\paragraph{Improved path-finding network} Instead of the\textit{ movement network} removing all of the positions from the inner ring of the non-moving robots, it would be possible to add re-introduce the actual source and legal move to the outer ring of the network. This would then reduce the number of hard-coded steps to the final 'move to inner ring', which would be kept in the program to make sure the timing of the final step was the same for both platforms.
\paragraph{Function for deciding order of operations}

For a three agent system, it is possible to exhaustively manually search through the possible arrangement of the robots and hence workout the correct order of operations. However, where there are more than three robots in the system, it is not obvious what the correct order would be. It would be possible to write a function that calculates the correct order of operations for any number of robots in any direction. This, however, is a challenging task.

\paragraph{Efficient Assignment of Path-finding Targets}

For the development of a more efficient path-finding algorithm, that has less steps for the robots to take (on average), requires a more complex layer of logic that can be added to the program in the future.

This would require the computation of all the possible targets from all the sources for each robot. From this the path-finding targets must be set so that the average number of steps for each robot is as close to the mean of the selected choices. This would set the values so there are not extreme values for the path-finding (hence one robot does not have a very large number of steps to make compared with a very small number of steps to take for another robot so the time for which any robot in the system remains still is reduced, so the robot time is not wasted waiting for other robots to move to their - far-away - targets.

\paragraph{Multi-Agent Path Finding (MAPF) Algorithms } 

The implementation of path-finding for both of the robots at once would be a way of reducing the run time of each step as both platforms would be able to move to their goal at once, reducing the time between animal decisions.

This is an area of research which has growing interest due to its use in multi-robot systems such as robotics-run run warehouses. There are implementations of this which are centralised such as the A* algorithm multi-agent systems \cite{DBLP:journals/corr/abs-2103-09979} or decentralised ways of organising behaviour such as the use of 'virtual pheromones' \cite{multi_agent_pathfinding_review} to communicate to many agents at once. 

% The computational time required compute the best path, for the A* algorithm, can take significant computational run time ($\mathcal{O}(n \cdot log(n)$) as you increase the number of robots in the system

These are useful generalisations of path-finding algorithms for many agents, however for Honeycomb Maze an inefficient algorithm is implemented without this being the limiting factor in the speed of the algorithm due to the low number of agents in the system.
However, if MAPF was successfully implemented it would be possible to execute the commands for both the robots at once, allowing for a faster running algorithm.








% placing the work in context 

% Comparison of similar problems and their solution and how they are different to yours


% Abstract: 
% Intro:500
% Implementation:2250
% Results: 190
% Discussion:900
% Appendix: 500